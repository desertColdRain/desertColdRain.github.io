# RabbitMQ
## 1. RabbitMQ架构设计
![](assets/RabbitMQ架构.png)

producer：生产者发送消息的时候会有一个routerKey，就是图中的binding，确定消息发送到哪个队列

Broker：标识消息队列服务器实体rabbitmq-server

Exchange：交换器用来接收生产者发送的消息并将这些消息路由给服务器中的队列，和队列的关系可以是多对多的关系

Queue： 消息队列，用来保存消息直到发送给消费者。它是消息的容器，也是消息的终点。一个消息可投入一个或多个队列。消息一直在队列里面，等待消费者连接到这个队列将其取走

Banding：绑定，用于消息队列和交换机之间的关联。一个绑定就是基于路由键将交换机和消息队列连接起来的路由规则，所以可以将交换器理解成一个由绑定构成的路由表

Channel：信道，多路复用连接中的一条独立的双向数据流通道。信道是建立在真实的TCP连接内地虚拟链接，AMQP命令都是通过信道发出去的，不管是发布消息、订阅队列还是接收消息，这些动作都是通过信道完成。因为对于操作系统来说，建立和销毁TCP都是非常昂贵的开销，所以引入了信道的概念，以复用一条TCP连接

Connection：网络连接，比如一个TCP连接。

consumer：消费者，可以主动去获取消息，也可以由MQ发送，被动接收
## 2. RabbitMQ交换机类型
交换器会先找出绑定的队列，然后再判断routerKey，来决定是否将某一个消息分发到某一个队列中
1. fanout：扇形交换机，不再判断routerKey，直接将消息发送到所有绑定的队列
2. direct：判断routerKey的规则是完全匹配模式，发送消息指定的routerKey等于要绑定的routerKey
3. topic：判断routerKey的规则时模糊匹配模式，比如routerKey为“li*”,，可以匹配"lisi","lishi"
4. header：  不处理路由键。而是根据发送的消息内容中的headers属性进行匹配。在绑定Queue与Exchange时指定一组键值对；当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers属性是一个键值对，可以是Hashtable，键值对的值可以是任何类型。而fanout，direct，topic 的路由键都需要要字符串形式的。
匹配规则x-match有下列两种类型：
  x-match = all ：表示所有的键值对都匹配才能接受到消息
  x-match = any ：表示只要有键值对匹配就能接受到消息
## 3.RabbitMQ持久化机制
主要包含三个方面的持久化

1. 交换机持久化
2. 队列持久化
3. 消息持久化

append的方式写文件。会根据文件的大小自动切割文件，rabbitMQ创建时会创建两个进程，一个负责消息持久化的存储，另一个负责非持久化消息的存储（内存不够时）

消息存储时会在ets表中记录消息在文件中的映射以及相关信息（包括id、偏移量、有效数据、左边文件、右边文件），消息读取时根据该信息到文件中读取，同时更新信息

消息删除时只从ets表中删除，变为垃圾数据，当垃圾数据超出比例（默认50%），并且文件数达到三个，触发垃圾回收，锁定左右两个文件，整理左边文件有效数据、将右边文件有效数据写入左边，更新文件信息，删除右边，完成合并，当一个文件的有用数据等于0时，删除该文件

写入文件前先写buffer缓冲区，如果buffer已满，则写入文件（此时只是操作系统的页存）

每隔25ms刷一次磁盘，不管buffer满没满，都将buffer和页存中的数据落盘

每次消息写入后，如果没有后序写入请求，则直接刷盘

## 4. RabbitMQ事务消息机制
RabbitMQ中与事务机制有关的方法有三个：txSelect(), txCommit()以及txRollback(), txSelect用于将当前channel设置成transaction模式，txCommit用于提交事务，txRollback用于回滚事务，在通过txSelect开启事务之后，我们便可以发布消息给broker代理服务器了，如果txCommit提交成功了，则消息一定到达了broker了，如果在txCommit执行之前broker异常崩溃或者由于其他原因抛出异常，这个时候我们便可以捕获异常通过txRollback回滚事务了。

事务机制类似于数据库的事务机制

生产者
```Java

public class Send {
    private static final String QUEUE_NAME = "QUEUE_simple";

    public static void main(String[] args) throws IOException, TimeoutException {
         /* 获取一个连接 */
        Connection connection = ConnectionUtils.getConnection();
        /* 从连接中创建通道 */
        Channel channel = connection.createChannel();
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        String msg = "Hello  Simple QUEUE !";
        try {
            channel.txSelect();
            channel.basicPublish("", QUEUE_NAME, null, msg.getBytes());
            int result = 1 / 0;
            channel.txCommit();
        } catch (Exception e) {
            channel.txRollback();
            System.out.println("----msg rollabck ");
        } finally {
            channel.close();
            connection.close();
        }
    }
}
```
消费者
```Java
public class Recover {
    private static final String QUEUE_NAME = "QUEUE_simple";
    public static void main(String[] args) throws Exception {
        Connection connection = ConnectionUtils.getConnection();
        Channel channel = connection.createChannel();
        channel.queueDeclare(QUEUE_NAME, false, false, false, null);
        DefaultConsumer consumer = new DefaultConsumer(channel) {
            //获取到达的消息
            @Override
            public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException {
                String message = new String(body, "UTF-8");
                System.out.println(" [x] Received '" + message + "'");
            }
        };
        //监听队列
        channel.basicConsume(QUEUE_NAME, true, consumer);
    }
}
```
